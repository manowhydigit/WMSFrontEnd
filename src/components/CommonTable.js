import React, { useState, useEffect } from "react";
import { MaterialReactTable } from "material-react-table";
import {
  Box,
  Button,
  Typography,
  MenuItem,
  Select,
  FormControl,
  Input,
} from "@mui/material";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import UWLNL from "../UWLNL.jpg";
import ExcelJS from "exceljs";
import { saveAs } from "file-saver";
import "./CommonTable.css";
// import { mkConfig, generateCsv, download } from "export-to-csv";
import { mkConfig, generateCsv, download as downloadCsv } from "export-to-csv";
import * as XLSX from "xlsx";

const CommonTable = ({ columns, data, filters }) => {
  const [pagination, setPagination] = useState({
    pageIndex: 0,
    pageSize: 10,
  });

  const [tableData, setTableData] = useState(data); // Track the table data state

  // CSV configuration
  const csvConfig = mkConfig({
    fieldSeparator: ",",
    decimalSeparator: ".",
    useKeysAsHeaders: true,
  });

  // Function to handle exporting all data to Excel
  const handleExportDataToExcel = () => {
    exportToExcel(tableData);
  };

  // const exportToExcel = async (data) => {
  //   try {
  //     // Filter out SNo column (case-sensitive)
  //     const filteredColumns = columns.filter(
  //       (col) =>
  //         col.id !== "SNo" &&
  //         col.id !== "sno" &&
  //         col.accessorKey !== "SNo" &&
  //         col.accessorKey !== "sno"
  //     );

  //     const header = filteredColumns.map(
  //       (col) => col.header || col.accessorKey
  //     );

  //     // Get current date and time
  //     const now = new Date();
  //     const formattedDateTime = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;

  //     // Get username from localStorage
  //     const username = localStorage.getItem("userName") || "Unknown User";

  //     // Create a new workbook
  //     const workbook = new ExcelJS.Workbook();
  //     // const worksheet = workbook.addWorksheet("Sheet1");
  //     const worksheet = workbook.addWorksheet("Sheet1", {
  //       views: [{ showGridLines: false }],
  //     });

  //     // Convert the logo image to base64
  //     const logoBase64 = await fetch(UWLNL)
  //       .then((response) => response.blob())
  //       .then(
  //         (blob) =>
  //           new Promise((resolve, reject) => {
  //             const reader = new FileReader();
  //             reader.onloadend = () => resolve(reader.result.split(",")[1]);
  //             reader.onerror = reject;
  //             reader.readAsDataURL(blob);
  //           })
  //       );

  //     // Add company logo
  //     const logoId = workbook.addImage({
  //       base64: logoBase64,
  //       extension: "png",
  //     });

  //     // Add logo to worksheet
  //     worksheet.addImage(logoId, {
  //       tl: { col: 0, row: 0 },
  //       ext: { width: 200, height: 50 },
  //     });

  //     // Add space after logo
  //     worksheet.addRow([]);
  //     worksheet.addRow([]);

  //     // Add report info section
  //     const reportInfoRow = worksheet.addRow([
  //       `Report generated by: ${username}`,
  //     ]);
  //     const dateTimeRow = worksheet.addRow([
  //       `Generated on: ${formattedDateTime}`,
  //     ]);

  //     // Apply styling to report info rows
  //     [reportInfoRow, dateTimeRow].forEach((row) => {
  //       row.font = { italic: true, color: { argb: "FF555555" } };
  //     });

  //     worksheet.addRow([]);

  //     // Add filter information
  //     if (filters) {
  //       // Title for filter section
  //       const filterTitleRow = worksheet.addRow(["Filter Criteria"]);
  //       filterTitleRow.font = { bold: true };
  //       filterTitleRow.eachCell((cell) => {
  //         cell.fill = {
  //           type: "pattern",
  //           pattern: "solid",
  //           fgColor: { argb: "FFD3D3D3" }, // Light gray background
  //         };
  //       });

  //       // Add filter values
  //       if (filters.branchname) {
  //         worksheet.addRow([`Branch: ${filters.branchname}`]);
  //       }
  //       if (filters.customer) {
  //         worksheet.addRow([`Customer: ${filters.customer}`]);
  //       }
  //       if (filters.ptype) {
  //         worksheet.addRow([`Type: ${filters.ptype}`]);
  //       }
  //       // if (filters.fromdt) {
  //       //   worksheet.addRow([`From Date: ${filters.fromdt}`]);
  //       // }
  //       // if (filters.todt) {
  //       //   worksheet.addRow([`To Date: ${filters.todt}`]);
  //       // }

  //       if (filters.fromdt) {
  //         // Format the from date as DD/MM/YYYY
  //         const fromDate = new Date(filters.fromdt);
  //         const formattedFromDate = `${String(fromDate.getDate()).padStart(
  //           2,
  //           "0"
  //         )}/${String(fromDate.getMonth() + 1).padStart(
  //           2,
  //           "0"
  //         )}/${fromDate.getFullYear()}`;
  //         worksheet.addRow([`From Date: ${formattedFromDate}`]);
  //       }
  //       if (filters.todt) {
  //         // Format the to date as DD/MM/YYYY
  //         const toDate = new Date(filters.todt);
  //         const formattedToDate = `${String(toDate.getDate()).padStart(
  //           2,
  //           "0"
  //         )}/${String(toDate.getMonth() + 1).padStart(
  //           2,
  //           "0"
  //         )}/${toDate.getFullYear()}`;
  //         worksheet.addRow([`To Date: ${formattedToDate}`]);
  //       }
  //       if (filters.div) {
  //         worksheet.addRow([`With Details: ${filters.div}`]);
  //       }

  //       // Add empty row after filters
  //       worksheet.addRow([]);
  //       worksheet.addRow([]);

  //       // âœ¨ Merged report title
  //       const title = "Party Ledger Report";
  //       const mergedHeaderRow = worksheet.addRow([title]);
  //       worksheet.mergeCells(
  //         `A${mergedHeaderRow.number}:E${mergedHeaderRow.number}`
  //       );
  //       mergedHeaderRow.getCell(1).font = {
  //         size: 16,
  //         bold: true,
  //         color: { argb: "FF000000" },
  //       };
  //       mergedHeaderRow.getCell(1).alignment = {
  //         horizontal: "center",
  //         vertical: "middle",
  //       };

  //       // Add spacing
  //       worksheet.addRow([]);
  //     }

  //     // Add headers with yellow background
  //     const headerRow = worksheet.addRow(header);

  //     // Style the header row
  //     headerRow.eachCell((cell) => {
  //       cell.fill = {
  //         type: "pattern",
  //         pattern: "solid",
  //         fgColor: { argb: "FFFFFF00" }, // Yellow background
  //       };
  //       cell.font = {
  //         bold: true,
  //         color: { argb: "FF000000" }, // Black text
  //       };
  //       cell.border = {
  //         top: { style: "thin" },
  //         left: { style: "thin" },
  //         bottom: { style: "thin" },
  //         right: { style: "thin" },
  //       };
  //     });

  //     // Add data rows, filtering out sno column
  //     data.forEach((item) => {
  //       const rowData = filteredColumns.map(
  //         (col) => item[col.accessorKey || col.id]
  //       );
  //       const row = worksheet.addRow(rowData);

  //       // Style the data cells
  //       row.eachCell((cell) => {
  //         cell.font = {
  //           color: { argb: "FF000000" }, // Black text
  //         };
  //         cell.border = {
  //           top: { style: "thin" },
  //           left: { style: "thin" },
  //           bottom: { style: "thin" },
  //           right: { style: "thin" },
  //         };

  //         // Right-align numbers
  //         if (typeof value === "number") {
  //           cell.alignment = { horizontal: "right" };
  //           cell.numFmt = "#,##0.00"; // Optional: format with 2 decimal places
  //         }

  //         // Apply maroon color for specific rows if needed
  //         if (["0", "0.1", "3", "4"].includes(item.sno)) {
  //           cell.font = {
  //             color: { argb: "FF800000" }, // Maroon text
  //           };
  //         }
  //       });
  //     });

  //     // Auto-fit columns
  //     worksheet.columns.forEach((column) => {
  //       let maxLength = 0;
  //       column.eachCell({ includeEmpty: true }, (cell) => {
  //         const columnLength = cell.value ? cell.value.toString().length : 0;
  //         if (columnLength > maxLength) {
  //           maxLength = columnLength;
  //         }
  //       });
  //       column.width = maxLength < 10 ? 10 : maxLength + 2;
  //     });

  //     // Generate the Excel file
  //     const buffer = await workbook.xlsx.writeBuffer();
  //     saveAs(new Blob([buffer]), "party_ledger_report.xlsx");
  //   } catch (error) {
  //     console.error("Error exporting to Excel:", error);
  //   }
  // };

  // const exportToExcel = async (data) => {
  //   try {
  //     const header = columns.map((col) => col.header || col.accessorKey);
  //     // Create a new workbook
  //     const workbook = new ExcelJS.Workbook();
  //     const worksheet = workbook.addWorksheet("Sheet1");

  //     // Convert the logo image to base64
  //     const logoBase64 = await fetch(UWLNL)
  //       .then((response) => response.blob())
  //       .then(
  //         (blob) =>
  //           new Promise((resolve, reject) => {
  //             const reader = new FileReader();
  //             reader.onloadend = () => resolve(reader.result.split(",")[1]);
  //             reader.onerror = reject;
  //             reader.readAsDataURL(blob);
  //           })
  //       );

  //     const filterRows = [
  //       [`Branch: ${filters.branchname || "-"}`],
  //       [`Customer: ${filters.customer || "-"}`],
  //       [`From Date: ${filters.fromdt || "-"}`],
  //       [`To Date: ${filters.todt || "-"}`],
  //       [],
  //       header,
  //     ];

  //     // Add company logo
  //     const logoId = workbook.addImage({
  //       base64: logoBase64,
  //       extension: "png",
  //     });

  //     // Add logo to worksheet
  //     worksheet.addImage(logoId, {
  //       tl: { col: 0, row: 0 },
  //       ext: { width: 200, height: 50 },
  //     });

  //     // Add space between logo and table
  //     worksheet.addRow([]);
  //     worksheet.addRow([]);
  //     worksheet.addRow([]);

  //     // Filter out sno column from headers
  //     // Filter out SNo column (case-sensitive)
  //     const filteredColumns = columns.filter(
  //       (col) =>
  //         col.id !== "SNo" &&
  //         col.id !== "sno" &&
  //         col.accessorKey !== "SNo" &&
  //         col.accessorKey !== "sno"
  //     );

  //     // Add headers with yellow background starting from row 4
  //     const headerRow = worksheet.addRow(
  //       filteredColumns.map((col) => col.header)
  //     );

  //     // Style the header row
  //     headerRow.eachCell((cell) => {
  //       cell.fill = {
  //         type: "pattern",
  //         pattern: "solid",
  //         fgColor: { argb: "FFFFFF00" }, // Yellow background
  //       };
  //       cell.font = {
  //         bold: true,
  //         color: { argb: "FF000000" }, // Black text
  //       };
  //       cell.border = {
  //         top: { style: "thin" },
  //         left: { style: "thin" },
  //         bottom: { style: "thin" },
  //         right: { style: "thin" },
  //       };
  //     });

  //     // Add data rows, filtering out sno column
  //     data.forEach((item) => {
  //       const rowData = filteredColumns.map(
  //         (col) => item[col.accessorKey || col.id]
  //       );
  //       const row = worksheet.addRow(rowData);

  //       // Style the data cells
  //       row.eachCell((cell) => {
  //         cell.font = {
  //           color: { argb: "FF000000" }, // Black text
  //         };
  //         cell.border = {
  //           top: { style: "thin" },
  //           left: { style: "thin" },
  //           bottom: { style: "thin" },
  //           right: { style: "thin" },
  //         };

  //         // Apply maroon color for specific rows if needed
  //         if (["0", "0.1", "3", "4"].includes(item.sno)) {
  //           cell.font = {
  //             color: { argb: "FF800000" }, // Maroon text
  //           };
  //         }
  //       });
  //     });

  //     // Auto-fit columns
  //     worksheet.columns.forEach((column) => {
  //       let maxLength = 0;
  //       column.eachCell({ includeEmpty: true }, (cell) => {
  //         const columnLength = cell.value ? cell.value.toString().length : 0;
  //         if (columnLength > maxLength) {
  //           maxLength = columnLength;
  //         }
  //       });
  //       column.width = maxLength < 10 ? 10 : maxLength + 2;
  //     });

  //     // Generate the Excel file
  //     const buffer = await workbook.xlsx.writeBuffer();
  //     saveAs(new Blob([buffer]), "exported_data.xlsx");
  //   } catch (error) {
  //     console.error("Error exporting to Excel:", error);
  //   }
  // };

  // const exportToExcel = async (data, filters = {}) => {
  //   try {
  //     const workbook = new ExcelJS.Workbook();
  //     const worksheet = workbook.addWorksheet("Sheet1");

  //     // Add logo (your existing logo code here)

  //     // Add filter parameters at the top
  //     if (Object.keys(filters).length > 0) {
  //       // Add logo (your existing logo code here)
  //       const logoBase64 = await fetch(UWLNL)
  //         .then((response) => response.blob())
  //         .then(
  //           (blob) =>
  //             new Promise((resolve, reject) => {
  //               const reader = new FileReader();
  //               reader.onloadend = () => resolve(reader.result.split(",")[1]);
  //               reader.onerror = reject;
  //               reader.readAsDataURL(blob);
  //             })
  //         );

  //       // Add company logo
  //       const logoId = workbook.addImage({
  //         base64: logoBase64,
  //         extension: "png",
  //       });

  //       // Add logo to worksheet
  //       worksheet.addImage(logoId, {
  //         tl: { col: 0, row: 0 },
  //         ext: { width: 200, height: 50 },
  //       });

  //       // Add space after logo
  //       worksheet.addRow([]);

  //       // Add filter parameters

  //       // Add empty row before table
  //       worksheet.addRow([]);
  //     }

  //     // Filter out SNo column
  //     const filteredColumns = columns.filter(
  //       (col) =>
  //         col.id !== "SNo" &&
  //         col.id !== "sno" &&
  //         col.accessorKey !== "SNo" &&
  //         col.accessorKey !== "sno"
  //     );

  //     // Add headers
  //     const headerRow = worksheet.addRow(
  //       filteredColumns.map((col) => col.header)
  //     );

  //     // Style headers (your existing header styling code here)
  //     headerRow.eachCell((cell) => {
  //       cell.fill = {
  //         type: "pattern",
  //         pattern: "solid",
  //         fgColor: { argb: "FFFFFF00" }, // Yellow background
  //       };
  //       cell.font = {
  //         bold: true,
  //         color: { argb: "FF000000" }, // Black text
  //       };
  //       cell.border = {
  //         top: { style: "thin" },
  //         left: { style: "thin" },
  //         bottom: { style: "thin" },
  //         right: { style: "thin" },
  //       };
  //     });

  //     // Add data rows
  //     data.forEach((item) => {
  //       const rowData = filteredColumns.map(
  //         (col) => item[col.accessorKey || col.id]
  //       );
  //       const row = worksheet.addRow(rowData);

  //       // Apply styling (your existing row styling code here)
  //       row.eachCell((cell) => {
  //         cell.font = {
  //           color: { argb: "FF000000" }, // Black text
  //         };
  //         cell.border = {
  //           top: { style: "thin" },
  //           left: { style: "thin" },
  //           bottom: { style: "thin" },
  //           right: { style: "thin" },
  //         };

  //         if (["0", "0.1", "3", "4"].includes(item.sno)) {
  //           cell.font = {
  //             color: { argb: "FF800000" }, // Maroon text
  //           };
  //         }
  //       });
  //     });

  //     // Auto-fit columns
  //     worksheet.columns.forEach((column) => {
  //       let maxLength = 0;
  //       column.eachCell({ includeEmpty: true }, (cell) => {
  //         const columnLength = cell.value ? cell.value.toString().length : 0;
  //         if (columnLength > maxLength) maxLength = columnLength;
  //       });
  //       column.width = Math.min(Math.max(maxLength + 2, 10), 50);
  //     });

  //     // Generate the Excel file
  //     const buffer = await workbook.xlsx.writeBuffer();
  //     saveAs(new Blob([buffer]), "party_ledger_report.xlsx");
  //   } catch (error) {
  //     console.error("Error exporting to Excel:", error);
  //   }
  // };

  // Example of how to convert an image to base64

  const exportToExcel = async (data) => {
    try {
      // Filter out SNo column (case-sensitive)
      const filteredColumns = columns.filter(
        (col) =>
          col.id !== "SNo" &&
          col.id !== "sno" &&
          col.accessorKey !== "SNo" &&
          col.accessorKey !== "sno"
      );

      const header = filteredColumns.map(
        (col) => col.header || col.accessorKey
      );
      const headerLength = header.length;

      // Get current date and time
      const now = new Date();
      const formattedDateTime = `${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;

      // Get username from localStorage
      const username = localStorage.getItem("userName") || "Unknown User";

      // Create a new workbook
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet("Sheet1", {
        views: [{ showGridLines: false }],
      });

      // Convert the logo image to base64
      const logoBase64 = await fetch(UWLNL)
        .then((response) => response.blob())
        .then(
          (blob) =>
            new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onloadend = () => resolve(reader.result.split(",")[1]);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            })
        );

      // Add company logo
      const logoId = workbook.addImage({
        base64: logoBase64,
        extension: "png",
      });
      worksheet.addImage(logoId, {
        tl: { col: 0, row: 0 },
        ext: { width: 200, height: 50 },
      });

      worksheet.addRow([]);
      worksheet.addRow([]);

      // Helper: merge and center any text row across header columns
      const mergeAndCenterRow = (text) => {
        const row = worksheet.addRow([text]);
        const lastColLetter = worksheet.getColumn(headerLength).letter;
        worksheet.mergeCells(`A${row.number}:${lastColLetter}${row.number}`);
        row.getCell(1).alignment = { horizontal: "center" };
        return row;
      };

      // Company Name (centered)
      mergeAndCenterRow("Uniworld Logistics Pvt Ltd").font = {
        size: 14,
        bold: true,
        color: { argb: "FF000000" },
      };

      // Report info (centered)
      mergeAndCenterRow(`Report generated by: ${username}`).font = {
        italic: true,
        color: { argb: "FF555555" },
      };
      mergeAndCenterRow(`Generated on: ${formattedDateTime}`).font = {
        italic: true,
        color: { argb: "FF555555" },
      };

      // Title
      mergeAndCenterRow("Party Ledger Report").font = {
        size: 16,
        bold: true,
        color: { argb: "FF000000" },
      };

      worksheet.addRow([]);

      // Add filter information
      if (filters) {
        const filterTitleRow = mergeAndCenterRow("Filter Criteria");
        filterTitleRow.font = { bold: true };
        filterTitleRow.eachCell((cell) => {
          cell.fill = {
            type: "pattern",
            pattern: "solid",
            fgColor: { argb: "FFD3D3D3" },
          };
        });

        if (filters.branchname) {
          mergeAndCenterRow(`Branch: ${filters.branchname}`);
        }
        if (filters.customer) {
          mergeAndCenterRow(`Customer: ${filters.customer}`);
        }
        if (filters.ptype) {
          mergeAndCenterRow(`Type: ${filters.ptype}`);
        }

        if (filters.fromdt) {
          const fromDate = new Date(filters.fromdt);
          const formattedFromDate = `${String(fromDate.getDate()).padStart(
            2,
            "0"
          )}/${String(fromDate.getMonth() + 1).padStart(
            2,
            "0"
          )}/${fromDate.getFullYear()}`;
          mergeAndCenterRow(`From Date: ${formattedFromDate}`);
        }
        if (filters.todt) {
          const toDate = new Date(filters.todt);
          const formattedToDate = `${String(toDate.getDate()).padStart(
            2,
            "0"
          )}/${String(toDate.getMonth() + 1).padStart(
            2,
            "0"
          )}/${toDate.getFullYear()}`;
          mergeAndCenterRow(`To Date: ${formattedToDate}`);
        }

        if (filters.div) {
          mergeAndCenterRow(`With Details: ${filters.div}`);
        }

        worksheet.addRow([]);
      }

      // Header row
      const headerRow = worksheet.addRow(header);
      headerRow.eachCell((cell) => {
        cell.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FFFFFF00" },
        };
        cell.font = {
          bold: true,
          color: { argb: "FF000000" },
        };
        cell.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" },
        };
      });

      // Data rows
      data.forEach((item) => {
        const rowData = filteredColumns.map(
          (col) => item[col.accessorKey || col.id]
        );
        const row = worksheet.addRow(rowData);

        row.eachCell((cell) => {
          const cellValue = cell.value;

          cell.font = {
            color: { argb: "FF000000" },
          };
          cell.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" },
          };

          if (typeof cellValue === "numeric") {
            cell.alignment = { horizontal: "right" };
            cell.numFmt = "#,##0.00";
          }

          if (["0", "0.1", "3", "4"].includes(item.sno)) {
            cell.font = {
              color: { argb: "FF800000" },
            };
          }
        });
      });

      // Auto-fit columns
      worksheet.columns.forEach((column) => {
        let maxLength = 0;

        column.eachCell({ includeEmpty: false }, (cell) => {
          let value = cell.value;
          if (value == null) return;

          if (typeof value === "object" && value.richText) {
            value = value.richText.map((t) => t.text).join("");
          }

          const columnLength = value.toString().length;
          if (columnLength > maxLength) {
            maxLength = columnLength;
          }
        });

        // ðŸ‘‡ Final width formula: min 10, max 25
        column.width = Math.min(Math.max(maxLength + 2, 10), 25);
      });

      // Export file
      const buffer = await workbook.xlsx.writeBuffer();
      saveAs(new Blob([buffer]), "party_ledger_report.xlsx");
    } catch (error) {
      console.error("Error exporting to Excel:", error);
    }
  };

  function toBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result.split(",")[1]);
      reader.onerror = (error) => reject(error);
    });
  }

  // Function to calculate the grand total for numeric columns

  // Function to handle page changes
  const handlePageChange = (newPageIndex) => {
    setPagination((prevPagination) => ({
      ...prevPagination,
      pageIndex: newPageIndex,
    }));
  };

  // Function to handle page size changes
  const handlePageSizeChange = (newPageSize) => {
    setPagination((prevPagination) => ({
      ...prevPagination,
      pageSize: newPageSize,
    }));
  };

  // Function to handle exporting rows to CSV
  const handleExportRows = (rows) => {
    const rowData = rows.map((row) => row.original);
    const csv = generateCsv(csvConfig)(rowData);
    downloadCsv(csvConfig)(csv); // Fixed: using downloadCsv instead of download
  };

  // Function to handle exporting all data to CSV
  const handleExportData = () => {
    const csv = generateCsv(csvConfig)(tableData);
    downloadCsv(csvConfig)(csv); // Fixed: using downloadCsv instead of download
  };

  // Function to handle exporting rows

  // Helper function to check if value is numeric
  const isNumeric = (value) => !isNaN(value) && value !== null;

  // Dynamically add right alignment to numeric columns
  const dynamicColumns = columns.map((column) => ({
    ...column,
    cell: (info) => (
      <span
        style={{
          textAlign: isNumeric(info.getValue()) ? "right" : "left",
          display: "inline-block",
          width: "100%",
        }}
      >
        {info.getValue()}
      </span>
    ),
  }));

  return (
    <Box
      sx={{
        // boxShadow: "0 4px 5px rgba(0, 0, 0, 0.5)",
        boxShadow: "0 0 15px rgba(0, 0, 0, 0.3)",
        borderRadius: "18px",
        padding: "16px",
        backgroundColor: "white",
        overflow: "hidden",
        fontSize: "12px",
      }}
    >
      <MaterialReactTable
        columns={dynamicColumns}
        data={tableData}
        enableRowSelection={false} // This hides the checkbox column entirely
        columnFilterDisplayMode="popover"
        paginationDisplayMode="pages"
        positionToolbarAlertBanner="bottom"
        muiTableBodyCellProps={({ row, column }) => ({
          sx:
            column.id === "sno"
              ? { display: "none" }
              : {
                  color: ["0", "0.1", "3", "4"].includes(row.original.sno)
                    ? "maroon"
                    : "#333",
                  fontWeight: "bold",
                  fontFamily: "'Roboto', sans-serif",
                  lineHeight: "0.4",
                  fontSize: "12px",
                },
        })}
        muiTableHeadCellProps={({ column }) => ({
          sx:
            column.id === "sno"
              ? { display: "none" }
              : {
                  position: "sticky",
                  top: 0,
                  zIndex: 2,
                  backgroundColor: "#FFED86",
                  color: "black",
                  fontWeight: "bold",
                  fontFamily: "'Roboto', sans-serif",
                  lineHeight: "0.8",
                },
        })}
        state={{
          pagination,
        }}
        onPaginationChange={(newPagination) => setPagination(newPagination)}
        renderTopToolbarCustomActions={({ table }) => (
          <Box
            sx={
              {
                /* your existing styles */
              }
            }
          >
            {/* CSV Export Buttons (keep existing) */}
            {/* Excel Export Buttons */}
            {/* <Button
              onClick={handleExportDataToExcel}
              startIcon={<FileDownloadIcon />}
              sx={{
                backgroundColor: "#FFED86",
                color: "black",
                "&:hover": { backgroundColor: "#FFE04D" },
              }}
            >
              Export to Excel
            </Button> */}
            <button class="BtnDownload" onClick={handleExportDataToExcel}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                height="1em"
                viewBox="0 0 384 512"
                class="svgIcon"
              >
                <path d="M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path>
              </svg>
              <span class="icon2"></span>
            </button>
            <div
              style={{
                marginTop: "-30px",
                marginLeft: "60px",
                marginBottom: "10px",
              }}
            >
              {" "}
              Export To Excel
            </div>
            {/* <Button
              disabled={table.getPrePaginationRowModel().rows.length === 0}
              onClick={() =>
                handleExportRowsToExcel(table.getPrePaginationRowModel().rows)
              }
              startIcon={<FileDownloadIcon />}
              sx={{
                backgroundColor: "#FFED86",
                color: "black",
                "&:hover": { backgroundColor: "#FFE04D" },
              }}
            >
              Export All (Excel)
            </Button> */}
          </Box>
        )}
        renderPagination={({ table }) => (
          <Box
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              padding: "16px",
              gap: 2,
              flexWrap: "wrap",
            }}
          >
            <Box sx={{ display: "flex", alignItems: "center" }}>
              <Button
                onClick={() => handlePageChange(0)} // Jump to the first page
                disabled={pagination.pageIndex === 0}
                sx={{ marginRight: 8 }}
              >
                First
              </Button>
              <Button
                onClick={() => handlePageChange(pagination.pageIndex - 1)}
                disabled={pagination.pageIndex === 0}
                sx={{ marginRight: 2 }}
              >
                Previous
              </Button>

              <Typography variant="body1" sx={{ marginRight: 2 }}>
                Page {pagination.pageIndex + 1} of {table.getPageCount()}
              </Typography>

              <Button
                onClick={() => handlePageChange(pagination.pageIndex + 1)}
                disabled={pagination.pageIndex === table.getPageCount() - 1}
                sx={{ marginLeft: 2 }}
              >
                Next
              </Button>
              <Button
                onClick={() => handlePageChange(table.getPageCount() - 1)} // Jump to the last page
                disabled={pagination.pageIndex === table.getPageCount() - 1}
                sx={{ marginLeft: 2 }}
              >
                Last
              </Button>
            </Box>

            <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
              <Typography variant="body1">Go to page:</Typography>
              <Input
                type="number"
                value={pagination.pageIndex + 1}
                onChange={(e) => {
                  const pageIndex = Math.max(
                    0,
                    Math.min(
                      table.getPageCount() - 1,
                      Number(e.target.value) - 1
                    )
                  );
                  handlePageChange(pageIndex);
                }}
                sx={{
                  width: "60px",
                  textAlign: "center",
                }}
              />
            </Box>

            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                gap: 2,
              }}
            >
              <Typography variant="body1">Rows per page:</Typography>
              <FormControl
                variant="outlined"
                size="small"
                sx={{ minWidth: 120 }}
              >
                <Select
                  value={pagination.pageSize}
                  onChange={(e) => handlePageSizeChange(e.target.value)}
                  label="Rows per page"
                >
                  <MenuItem value={5}>5</MenuItem>
                  <MenuItem value={10}>10</MenuItem>
                  <MenuItem value={20}>20</MenuItem>
                  <MenuItem value={50}>50</MenuItem>
                </Select>
              </FormControl>
            </Box>
          </Box>
        )}
      />
    </Box>
  );
};

export default CommonTable;
